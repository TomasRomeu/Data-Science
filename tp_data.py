# -*- coding: utf-8 -*-
"""TP-DATA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pU2Gbg_L8z2yoAD1nahb25TxD1GRPdey

#Trabajo Practico - Data Science - Dicsys
![imagen_dicsys(2).png](data:image/png;base64,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)
"""

# Importamos las librerias necesarias para trabajar con set de datos

import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import os

def status(data):

    data2=data

    tot_rows=len(data2)
    
    d2=data2.isnull().sum().reset_index()
    d2.columns=['variable', 'q_nan']
    
    d2[['p_nan']]=d2[['q_nan']]/tot_rows
    
    d2['q_zeros']=(data2==0).sum().values

    d2['p_zeros']=d2[['q_zeros']]/tot_rows

    d2['unique']=data2.nunique().values
    
    d2['type']=[str(x) for x in data2.dtypes.values]
    
    return(d2)

peliculas = pd.read_csv('RatingsPeliculas.csv')

peliculas.shape

peliculas.head()

peliculas.info()

status(peliculas)

peliculas.Genero.value_counts()

peliculas.Genero.value_counts(normalize=True)

# Modificamos el nombre de las columnas, unificando criterio de nombres sin espacio

#Pelicula = nombre de la pelicula
#Genero = categoria que integra la pelicula
#RatingCriticos = puntaje de los criticos en porcentaje
#RatingAudiencia = puntaje de aceptacion por parte del publico en porcentaje
#PresupuestoMill = presupuesto de la pelicula en millones de dolares
#Lanzamiento = aÃ±o en que se estreno la pelicula

peliculas.columns = ['Pelicula','Genero','RatingCriticos','RatingAudiencia','PresupuestoMill','Lanzamiento']

peliculas.head()

# Definimos como CATEGORICO al 'Genero' y 'Lanzamiento':

peliculas.Genero = peliculas.Genero.astype('category')
peliculas.Lanzamiento = peliculas.Lanzamiento.astype('category')

peliculas.Genero.cat.categories

peliculas.Lanzamiento.cat.categories

#ignoramos los warnigns que aparacen encima del grafico
import warnings           
warnings.filterwarnings('ignore')

# BOXPLOT:
z = sns.boxplot(data = peliculas, x = 'Genero', y = 'RatingCriticos')

z1 = sns.boxplot(data = peliculas, x = 'Genero', y = 'RatingAudiencia')

# Diagrama de la densidad de kernel
sns.set_style('darkgrid')

k1 = sns.kdeplot(peliculas.RatingCriticos, peliculas.RatingAudiencia, shade = True, shade_lowest = False, cmap = 'Reds')

# Filtro para ver las peliculas que cuyo rating de criticos este entre 70 y 80

peliculas[(peliculas.RatingCriticos > 70) & (peliculas.RatingCriticos < 80)]

vis2 = sns.lmplot(data = peliculas[peliculas.Genero == 'Comedia'], x = 'RatingCriticos', y = 'PresupuestoMill', fit_reg = False, size = 6, hue = 'Genero')

sns.lineplot(x="RatingCriticos", y="RatingAudiencia", hue="Genero", data=peliculas[peliculas.Genero == 'Comedia'])

sns.set_style('darkgrid')
f, axes = plt.subplots(1, 2, figsize = (15, 5))
k1 = sns.kdeplot(peliculas.PresupuestoMill, peliculas.RatingAudiencia, 
                 shade= True, shade_lowest= True, cmap= 'inferno', ax = axes[0])
k1b = sns.kdeplot(peliculas.PresupuestoMill, peliculas.RatingAudiencia, 
                 cmap= 'cool', ax = axes[0])

k2 = sns.kdeplot(peliculas.PresupuestoMill, peliculas.RatingCriticos,
                 shade= True, shade_lowest= True, cmap= 'inferno', ax = axes[1])
k2b = sns.kdeplot(peliculas.PresupuestoMill, peliculas.RatingCriticos,
                 cmap= 'cool', ax = axes[1])

# Facet Grid:

g = sns.FacetGrid(peliculas, row = 'Genero', col = 'Lanzamiento', hue = 'Genero')
g = g.map(plt.scatter, 'RatingCriticos', 'RatingAudiencia')

# Distribucion:

f, axes = plt.subplots(2, 2, figsize = (15, 10))
vis = sns.distplot(peliculas['RatingAudiencia'], bins=30, ax = axes[0,0])
vis = sns.distplot(peliculas['RatingCriticos'], bins=30, ax = axes[0,1])
vis = sns.distplot(peliculas['PresupuestoMill'], bins=30, ax = axes[1,0])
vis = sns.distplot(peliculas['Lanzamiento'], bins=30, ax = axes[1,1])

# Filtro por peliculas que no tienen presupuesto

peliculas[peliculas.PresupuestoMill == 0]

# Peliculas que no tuvieron presupuesto

vis2 = sns.lmplot(data = peliculas[peliculas.PresupuestoMill == 0], x = 'RatingCriticos', y = 'RatingAudiencia', fit_reg = False, size = 6, hue = 'Genero')

# peliculas con cero 'RatingCriticos' y cero 'RatingAudiencia'
# peliculas[(peliculas.RatingCriticos == 0)]# & (peliculas.RatingAudiencia == 0)]
peliculas[(peliculas.RatingAudiencia == 0)]# & (peliculas.RatingAudiencia == 0)]

peliculas.Genero.value_counts(normalize=True)

#Primer grupo compuesto por los 3 generos que abarcan la mayoria de peliculas (Comedia, Accion, Drama)

fig = peliculas[peliculas.Genero=='Comedia'].plot(kind='scatter',x='RatingCriticos',y='RatingAudiencia',color='orange', label='Comedia')
peliculas[peliculas.Genero=='Accion'].plot.scatter(x='RatingCriticos',y='RatingAudiencia',color='blue', label='Accion',ax=fig)
peliculas[peliculas.Genero=='Drama'].plot.scatter(x='RatingCriticos',y='RatingAudiencia',color='red', label='Drama',ax=fig)
fig.set_xlabel("RatingCriticos")
fig.set_ylabel("RatingAudiencia")
fig.set_title("RatingCriticos VS RatingAudiencia")
fig=plt.gcf()
fig.set_size_inches(10,6)
plt.show()

# Segundo grupo compuesto por el resto de las categorias (Terror, Suspenso, Aventura, Romance)

fig2 = peliculas[peliculas.Genero=='Terror'].plot(kind='scatter',x='RatingCriticos',y='RatingAudiencia',color='orange', label='Terror')
peliculas[peliculas.Genero=='Suspenso'].plot.scatter(x='RatingCriticos',y='RatingAudiencia',color='blue', label='Suspenso',ax=fig2)
peliculas[peliculas.Genero=='Aventura'].plot.scatter(x='RatingCriticos',y='RatingAudiencia',color='red', label='Aventura',ax=fig2)
peliculas[peliculas.Genero=='Romance'].plot.scatter(x='RatingCriticos',y='RatingAudiencia',color='violet', label='Romance',ax=fig2)
fig2.set_xlabel("RatingCriticos")
fig2.set_ylabel("RatingAudiencia")
fig2.set_title("RatingCriticos VS RatingAudiencia")
fig2=plt.gcf()
fig2.set_size_inches(10,6)
plt.show()

# Correlacion:

plt.figure(figsize=(7,4)) 
sns.heatmap(peliculas.corr(),annot=True)
plt.show()

from sklearn.linear_model import LogisticRegression  
from sklearn.neighbors import KNeighborsClassifier 

from sklearn import tree

from sklearn.model_selection import train_test_split

peliculas.shape

# Creo otra dataframe partiendo del original para pruebas
peliculas2 = peliculas

peliculas2.head(2)

# Elimino la columna 'Pelicula' con el objetivo de analizar solo el 'Genero'
peliculas2.drop('Pelicula',axis=1,inplace=True)

peliculas2.head(2)

"""#Creamos las tablas de entrenamiento y validacion"""

# Utilizamos una proporcion 70/30 para las tablas de entrenamiento y validacion

X = peliculas2.iloc[:,1:].values
y = peliculas2.iloc[:,-5].values

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

print(X_train.shape)
print(y_train.shape)
print(X_test.shape)
print(y_test.shape)

"""##Regresion Logistica"""

model = LogisticRegression()
model.fit(X_train,y_train)
prediction=model.predict(X_test)
#print('accuracy:',metrics.accuracy_score(prediction,y_test))

from sklearn.metrics import classification_report,accuracy_score

report = classification_report(y_test, prediction)
print(report)

# se usa para ver como ajusta el modelo con los datos de entrenamiento
prediction=model.predict(X_train)
#print('accuracy:',metrics.accuracy_score(prediction,y_train))
report = classification_report(y_train, prediction)
print(report)